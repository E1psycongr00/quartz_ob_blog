---
tags:
  - 완성
  - OS
  - CPU
  - Process
aliases: 
title: CPU 스케줄링 알고리즘
date: 2024-01-16
---
작성 날짜: 2024-01-16
작성 시간: 21:50


----
## 내용(Content)
스케줄러에 대해 궁금하다면 [[CPU 스케줄러]] 참고

OS마다 다를 적용하는게 다를 순 있지만 CPU가 프로세스를 스케줄링하는데 몇가지 기법이 있다.

- FCFS
- SJF(Shortest Job First)
- SRTF(Shortest Remaining Time First)
- priority
- round robin(RR)
- MLFQ(Multi Level Feedback Queue)


### FCFS(First Come First Served)
먼저 들어온 프로세스를 먼저 처리하는 방식이다. 굉장히 직관적이고 비선점형 방식이다. 큐에 들어온 대로 그냥 처리한다고 보면 된다.

### SJF(Sortest Job First)
프로세스의 다음 CPU Burst가 가장 짧은 프로세스부터 실행하는 알고리즘이다.

SJF에는 기본적으로 비선점형으로 끝까지 프로세스를 실행한다.

우선 SJF의 기본 원리에 대해서 알아보자

P1: 5
P2: 3
P3: 10

이렇게 3개의 process가 있고 각각 실행 시간(CPU 버스트)가 5, 3, 10이라 가정하면 SJF 알고리즘이라면 P2 -> P1 -> P3 순으로 실행한다.



### SRTF(Shortest Remaining Time First)
CPU 버스트가 남은 것중 가장 짧은 프로세스를 실행하는 알고리즘이다. 실행하다가도 중간에 실행 시간이 짧은 프로세스가 들어오면 진행하던 프로세스를 멈추고 해당 프로세스를 실행한다. 그래서 선점형이다.


### Priority
우선순위 스케줄링 기법은 말 그대로 우선순위가 높은 프로세스를 먼저 실행하는 기법이다. 
선점형으로 만약 실행되고 있는 프로세스보다 우선순위가 더 높다면 기존 프로세스는 중단하고 새로 들어온 프로세스를 실행한다. 실행하면서 매번 우선순위가 높은 프로세스를 선택하는 것이다.

장점은 각 프로세스들의 상대적 중요성을 알기 쉽고 직관적이다. 하지만 단점은 우선 순위가 낮은 프로세스는 매번 밀려 계속해서 실행되지 못하는 단점이 있다.

우선 순위는 내부적, 외부적 2가지로 정의 가능하다.

내부적
- 제한 시간
- 기억장소 요청량
- 사용 파일 수
- 평균 프로세서 버스트

외부적
- 프로세스의 중요성
- 정책적 요인


### Round Robin(RR)
time slice로 나누어진 CPU time을 번갈아가면서 실행하는 알고리즘이다.

![[RR 스케줄링(draw).svg|600]]

위 그림을 보면 P1,P2,P3의 총 실행 시간이 있고, 이를 3ms씩 나눈다. 그리고 번갈아 가면서 실행한다. 이런 스케줄링의 장점은 priority처럼 우선순위가 밀려서 실행되지 않는 프로세스가 없다는 점이다. 그리고 번갈아가면서 실행되기에 빠른 응답성을 제공한다.

그러나 프로세스의 많은 전환은 많은 Context Switching 발생시키게 되고 이는 성능 저하로 이어진다.

선점형으로 빠른 응답성을 제공하기 때문에 실시간 시스템에 사용하면 좋다.

### MLFQ(Multi Level Feedback Queue)
여러 개의 큐로 구성되어 있고, 각 큐마다 다른 우선순위가 배정된다. MLFQ의 큰 특징은 무엇일까? 큐마다 우선 순위가 있고 큐들 마다 특성은 다르지만 RR 스케줄링이 적용된다.

RR알고리즘이 빠른 응답성을 주는 장점이 있지만 역시나 컨텍스트 스위칭이 자주 일어나기 때문에 늦은 반환 시간을 가진다.  SJF SRTF같은 경우도 버스트 기준으로 하더라도 실행시간을 정확히 파악하기는 사실상 불가능 하기 때문에 정확히 적용하기 어렵다는 단점이 있다.

MLFQ의 동작은 다음과 같이 진행된다.

**(긴 시간을 가진 프로세스가 입력으로 들어왔을 때 예시)**
![[Pasted image 20240119210248.png]]

**(MLFQ 알고리즘 동작 과정)**
![[MLFQ 동작 방식(draw).svg|600]]

계속해서 시분할 내에 프로세스를 끝내지 못하면 더 낮은 우선순위 큐로 옮긴다.  그래서 단점은 계속해서 우선순위가 높은 큐에 프로세스가 상주한다면 우선순위가 낮은 큐는 계속해서 실행되지 못하는 단점이 있다. 그래서 프로세스가 기아 상태에 빠지지 않게 일정 시간(부두 상수)이 지나면 상위 프로세스를 옮기는 방법으로 이를 해결한다.

MLFQ는 최적화를 위해 튜닝해야 할 변수가 많다.
1. 타임 슬라이스
2. 우선순위 큐의 갯수
3. 부두 상수
## 질문 & 확장

(없음)

## 출처(링크)
- https://wonit.tistory.com/108
- https://jwprogramming.tistory.com/17
- https://velog.io/@jewelrykim/%EB%A9%80%ED%8B%B0-%EB%A0%88%EB%B2%A8-%ED%94%BC%EB%93%9C%EB%B0%B1-%ED%81%90%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81
## 연결 노트
- [[CPU 스케줄러|CPU Scheduler]]









