---
tags:
  - 완성
  - 알고리즘
  - Greedy
aliases: 
title: 단속 카메라 문제
date: 2023-12-12
---
작성 날짜: 2023-12-12
작성 시간: 19:22

----

## 문제 & 원인
[단속 카메라 by 프로그래머스](https://school.programmers.co.kr/learn/courses/30/lessons/42884) 

단속 카메라 문제를 푸는데 사용되는 태크닉은 Interval Scheduling 문제, 우리나라에서는 회의실 배정 문제로 유명한 유형과 굉장히 비슷한 문제이다.

여기서 문제는 주어진 자동차를 모두 감시하기 위해 설치해야 하는 최소한의 카메라 갯수를 구하는 것이다.
## 해결 방안

### 그리디의 조건
Greedy 를 적용하기 전에 생각해봐야 할 것이 2가지가 있다.

1. 최적 부분 구조(Optimal Substructure)
	- 전체에서 구한 최적해 구하는 방식이 문제를 작게 쪼갠 부분 문제에서도 최적의 해가 적용되야 한다.
	- 전체 문제의 최적해를 부분 문제의 최적해로 나눠질 수 있어야 한다.(규칙이 있다)
2. 탐욕적 선택 속성(Greedy Choice Property)
	- 어떤 단계에서 수행한 최적해를 선택한 방식이 전체 최적화 문제의 일부여야 한다.

### 문제 접근하기

최대한 중첩되게 카메라를 최소한으로 선택하려면 어떻게 해야할까? 가장 좋은 방법은 끝나는 구간으로 간격들을 정렬하고, 구간이 끝나는 시점에 카메라를 설치하는 것이다. 그리고 다음 구간은 선택되지 않았던 남은 구간의 최초 구간의 끝나는 지점에 카메라를 설치한다.

과연 이런 규칙이 부분적으로 그리고 전체적으로도 최적일까?

![[단속 카메라 예제1(draw).svg|600]]

위와 같은 폐구간이 존재한다고 하자. 최소한의 줄을 그어서 모든 간격을 선택할 수 있게 하려면 2개가 필요하다. 

![[단속 카메라 원리1(draw).svg|600]]

위와 같이 끝나는 시점으로 정렬한 뒤 끝에 선을 그어야 하는 이유를 알아보자.

>[!example] 시작 지점에 긋는 경우
>시작 지점에 그으면 선택한 간격만이 선택되기 때문에 동시에 출발한 차량이 없다면 항상 1개이다.  고로 최대 겹치는 구간의 선이 될 수 없다.


>[!example] 중간 지점에 긋는 경우
>중간에 그으면 역시 최대의 구간이 겹치지 않는다. 위의 그림을 보면 충분히 이해가 될 것이다.


>[!example] 마지막 경계선에 긋는 경우
>마지막에 그어야 마지막 경계선 시작으로 하는 구간도 선택할 수 있기에 한 번 그었을 때 최대한 많은 구간을 선택할 수 있다.


우리는 예시를 통해 마지막에 선을 그으면 가장 많이 선택할 수 있음을 알았다.  그러면 이렇게 첫번째 과정을 선택하고 남은 구간에서도 이와 같은 규칙을 적용하면 최적해를 구할 수 있는지 증명만 하면 된다.

위의 그림에서 선택하고 남은 초록색 구간을 보자.  초록색 구간의 시작 지점은 사용한 노란색 구간과 겹치긴 하지만,  우리는 끝 지점으로 counting 할 것임으로 아무 문제가 없다. 여기서도 선택하지 않은 첫번째 구간의 마지막 구간을 경계선으로 선택했을 때 최대한의 구간을 선택하면 되는데, 첫번째로 선택한 파란 구간을 제외하고 해당 구간만으로 살펴봐도 역시 최적해를 구할 수 있다. 

첫번째로 구한 해와 2번째로 구한 해가 완전히 분리되고 남은 구간에서 여전히 같은 방식으로 최적해를 구할 수 있기 때문에 최적 부분 구조가 되며, 그리디 알고리즘이 적용될 수 있음을 알 수 있다.


### code
```java
import java.util.*;

class Solution {
    public int solution(int[][] routes) {
        Arrays.sort(routes, (x, y) -> Integer.compare(x[1], y[1]));
        int nowEnd = -30000 - 1;
        int count = 0;
        for (int[] route : routes) {
            int s = route[0];
            int e = route[1];
            if (s > nowEnd) {
                nowEnd = e;
                count++;
            }
        }
        return count;
    }
}
```

완전히 최적 부분 구조로 분리되기 위해선 선택되었던 구간이 다시 사용되면 안된다.  여기선 폐구간이므로 경계선의 구간도 선택 될 수 있기 때문에 다음 구간은 start 지점이 그어진 선(nowEnd) 보다 커야 한다.

만약 개구간이라 포함되지 않는 구간이라면 start >= nowEnd 조건이 될 것이다. 그 이유는 경계선 구간이 선택되지 않았기 때문에 다음에 선택해야 하기 때문이다.

## 질문 & 확장

- interval scheduling과 코드 유형이 상당히 비슷하다.

## 출처(링크)
- https://school.programmers.co.kr/learn/courses/30/lessons/42884

## 연결 노트










